## 单调栈

### 原理

栈中元素满足从小到大或从大到小的顺序，从而能找到距离当前元素最近的最大值或最小值

### 复杂度

时间复杂度：需要遍历一次+每次遍历时可能需要弹出栈+压入栈，压入栈只需要O(1)，弹出栈最坏情况会是O(n)，但是不可能每次都会出现最坏情况（如果之前出现过，下一次就不需要弹出了，栈已经是空的了），故总体时间复杂度为O(n)

空间复杂度：需要数组进行存储，最坏情况下会将整个数组都存入栈中，故总体空间复杂度为O(n)

### 实现代码

```c++
int tt = 0;
int stk[N];

for (int i = 0; i < n; ++i) {
  while (tt >= 0 && check(stk[tt], i)) --tt;
  stk[++tt] = i;
}
```

## 单调队列

### 原理

和单调栈一样，只不过可以限定查找的范围

### 实现代码

```c++
int hh = 0, tt = -1;
int q[N];
for (int i = 0; i < n; ++i) {
  while (hh <= tt && check_out(q[hh])) ++hh;
  while (hh <= tt && check(q[tt], i)) --tt;
  q[++tt] = i;
}
```

## KMP

### 原理

利用了最长前后缀匹配来避免匹配失败的不必要回溯，设s是长文本，p是模式串，当p[i]匹配到s[j]时不相等，为了避免重新匹配（设p[0]~p[i]这个子串为t），考虑这个t末尾和前缀最长的匹配是什么位置，从而让t头部移动到t末尾匹配的位置

s: ABCxxxxABCXXX => ABCxxxxABCXXX
p: ABCxxxxABCZ   =>        ABCxxxxABCZ

现在需要考虑如何计算出p在i位置时回溯的下标，也就是在0~i这个位置下最长的前后缀匹配长度，假设当前i已经匹配到位置j（i > j），那么i+1的位置需要考虑j+1的字母是否和i+1相等，不相等则回溯（和第一段文字方法一样，考虑0~j中j+1匹配失败了应该回溯到什么位置，从而继续和i+1匹配）

### 复杂度

时间复杂度：需要遍历子串和文本串，故需要O(n+m)

空间复杂度：需要额外的数组存储回溯位置，故需要O(m)

### 代码实现

```c++
// 求回溯下标
for (int i = 1, j = -1;i < m; ++i) {
  while (j >= 0 && p[i] != p[j + 1]) j = ne[j];
  if (p[i] == p[j + 1]) ++j;
  ne[i] = j;
}

// 匹配
for (int i = 0, j = -1; i < n; ++i) {
  while (j >= 0; s[i] != p[j + 1]) j = ne[j];
  if (s[i] == p[j + 1]) ++j;
  if (j == m) {
    // 匹配成功
    break;
  }
}
```

## 字典树

### 原理

有n个字符串，其中最大长度为m，那么为每个字符串都建立一个映射表，实现空间换时间

为了方便查找，组合在一个数组即可，N = n * m，数组中的值表示为字符串下一个字符的位置

### 复杂度

时间复杂度：为每个字符串都建立一遍位置索引，故需要O(n*m)

空间复杂度：需要存储索引，故需要O(n * m * 26)

### 代码实现

```c++
int tree[N][26], cnt[N], idx;

void insert(char* str) {
  int p = 0;
  for (int i = 0; str[i]; ++i) {
    int ch = str[i] - 'a';
    if (!tree[p][u]) tree[p][u] = ++idx;
    p = tree[p][u];
  }
}

int query(char* str) {
  int p = 0;
  for (int i = 0; str[i]; ++i) {
    int u = str[i] - 'a';
    if (!tree[p][u]) return 0;
    p = tree[p][u];
  }
  return cnt[p];
}
```
