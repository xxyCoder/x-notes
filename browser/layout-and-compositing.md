## 样式计算

1. 将css转化为styleSheets
2. 转化样式表中的属性值，使其标准化
3. 计算DOM树中每个节点都具体样式，考虑继承和层叠规则

## 布局

* 主线程遍历DOM和ComputedStyle，找出可见节点并加入到布局树中，然后针对布局树开始计算坐标位置和边界大小等信息
  * css文件阻塞会导致布局树无法生成（除非下载失败），从而导致页面白屏

## 分层

* 页面会被分成一块块图层，从而形成图层树，但不是每个节点都是一个图层，如果一个节点没有对应的图层则该节点属于父节点的图层

### 绘制

1. 渲染进程主线程将一个图层的绘制拆分为很多小的绘制指令，按顺序组成一个待绘制列表提交给合成线程执行
2. 合成线程将图层划分为图块（256 * 256或512 * 512），按照视口附近的图块优先生成位图
   1. 如果图层过大视口显示不下就没必要一次性生成位图
   2. 渲染进程维护了一个栅格化的线程池（图块栅格化转为位图都在该线程池中完成），可以使用GPU加速（需要跨进程通信）
3. 生成好位图后提交给浏览器进程，由浏览器进程中viz组件处理，将其绘制内容保存在内存中

## 合成线程接受输入事件

[输入即将到达合成器](https://developer.chrome.com/blog/inside-browser-part4?hl=zh-cn#input_is_coming_to_the_compositor)

* 对于页面滚动，合成线程只需要栅格化更多的位图用于展示即可，但是如果此时有事件监听函数（wheel、touchmove等非passive事件）怎么办

### 非快速滚动区域

* 在合成过程中如果有事件处理的图层标为“非快速滚动区域”，也就是说事件如果发生在该图层，合成线程需要等主线程处理后才能继续合成新帧
  * 如果在多个图层的共同祖先元素中写了事件（事件委托）会导致底下所有图层都被标记为“非快速滚动区域”

### 尽量减少对主线程的事件调度

* chrome会合并连续事件（如wheel、mousewheel等），并将调度延迟到下一个requestAnimationFrame之前
  * 可以通过getCoalescedEvents获取合并事件的信息
