# 接口调用

1. 接口都需要使用try...catch包裹，错误提示错误信息

```js
try {
  getData()
} catch(e) {
  message.error()
}
```

# 查询

1. 对于查询耗时1s及其以上的接口考虑添加loading
2. 查询前思考哪些数据是需要清空的
   * 清空数据为下次查询、报错后需要清空的数据
3. 查询使用try...catch包裹，报错提示错误信息

## 分页查

1. 监听页码和页量的变化去调用请求函数，或者手动在改变页码和页量的地方去调用请求函数

## 条件查

1. 条件查可以封装成一个查询组件，点击组件中的查询按钮向外抛出查询事件，并携带查询参数，然后调用请求函数，同时使用非响应式变量记录
   * 可以避免用户改变了条件，但是没有点击查询，后续分页查询的时候是根据最新条件查询的

## 实时查

1. 其他人的操作需要及时同步到当前用户中时，可以考虑前端不断轮询、SSE或者建立websocket连接
2. 对于不断轮询容易造成大量无用请求，浪费资源，但兼容性好
3. 对于SSE在高并发下会对服务器和网络造成一定压力（基于http协议实现的）
4. 对于webSocket有兼容性问题，有些旧浏览器可能不支持，高并发下有一定优势（长连接、异步通信）

# 新增

1. 新增有多个字段是使用对象存储还是多个变量存储？
   1. 使用对象的话能更加简洁，多个字段都在一个变量中，但是问题在于如果存在嵌套字段，性能可能不如多个变量存储
   2. 使用对象的话传递给后端可能需要多一层解构，因为数据字段不一定取的同名
   3. 考虑如果是内部有嵌套字段的单独拆一个变量
2. 无论是点击取消还是新增，都需要在结束后清空内部数据
3. 新增后是否调用查询接口获取新数据？
   1. 接口耗时较短可以考虑直接调用接口（同时也可以拿到其他用户的操作）
   2. 耗时较长的话，前端可以直接修改查询数据（已有新增数据，可以自己添加，如果有id这类数据，可以让后端在新增成功的接口返回id）
   3. 新增要注意插入数据有什么顺序要求等

# 修改

1. 修改时，需要将旧信息存储到当前修改组件的变量中
2. 修改有多个字段是使用对象存储还是多个变量存储？
   1. 如果后端返回的是有嵌套字段的对象，其中嵌套对象中有可能有null值，导致使用修改组件报错，不想报错的话需要针对嵌套字段做空值处理
   2. 同新增做法

```js
// 如果用户输入friends.name就可能报错，因为firends可能为null
{
  name: "",
  friends: {
    name: ""
  } | null
}
```

3. 结束后依旧需要清空数据
4. 是否调用接口同新增原理

# 删除

1. 删除需要二次确认组件
2. 删除后是否调用接口同上
