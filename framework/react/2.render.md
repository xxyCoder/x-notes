## React.render函数

1. 创建根节点容器
2. render函数主要是将element放入fiber的更新队列，然后从根fiber开始调度

```js
function createRoot(container) {
  const root = createContainer(container)

  return {
    render(reactElement) {
      return updateContainer(reactElement, root)
    }
  }
}

function updateContainer(reactElement, root) {
  const hostRootFiber = root.current
  const update = createUpdate(update)
  enqueueUpdate(
    hostRootFiber.updateQueue,
    update
  )
  scheduleUpdateOnFiber(hostRootFiber)
  return reactElement
}
```

## work loop

- 本质是递归，从当前节点开始“递”到子节点，知道没有子节点为止，然后开始向上“归”

### begin work

1. 根据type创建真实dom，并更新fiber属性
   
```js
function workLoop() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(fiber) {
  let next = beginWork(fiber);
  fiber.memorizedProps = fiber.pendingProps;
  if (next === null) {
    completeUnitOfWork(fiber); // 没有子节点
  } else {
    workInProgress = fiber;
  }
}

function completeUnitOfWork(fiber) {
  let node = fiber;
  do {
    completeWork(node); // 没有子节点的fiber说明当前dfs链路到尽头，需要找上级节点的其他子节点进行dfs，同时对当前fiber做完成工作
    const sibling = next.sibling;
    if (sibling !== null) {
      workInProgress = sibling;
      break;
    }
    // 说明上级没有其他子节点了，则回溯到上级节点，从而继续重复查找
    node = node.return;
    workInProgress = node;
  } while (node !== null);
}

function beginWork(wip) {
  const tag = wip.tag;

  switch (tag) {
    case HostRoot:
      return updateHostRoot(wip);
    case HostComponent:
      return updateHostComponent(wip);
    case HostText:
      return null;
    case FunctionComponent:
      return updateFunctionComponent(wip);
    case Fragment:
      return updateFragment(wip);
  }
}

function updateHostRoot(wip) {
  const prevState = wip.memorizedState;
  const updateQueue = wip.updateQueue;
  const pending = updateQueue.pending;
  updateQueue.pending = null;

  const { memorizedState } = processUpdateQueue(prevState, pending); // 消费update拿到最新的state
  wip.memorizedState = memorizedState;

  const nxtChild = memorizedState;
  reconcilChildren(wip, nxtChild);
  return wip.child;
}

function reconcilChildren(wip, children) {
  const current = wip.alternate;
  if (current) {
    // update
  } else {
    wip.child = mountChildFibers(wip, null, children); // 根据fiber type创建真实的dom
  }
}
```
