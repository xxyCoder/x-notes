## 开启条件

1. 使用ESM规范编写代码，从而允许在编译阶段确定模块间的导入/导出关系，从而分析出未被使用的代码
2. optimization.usedExports: true，启用标记功能
3. 启动优化代码功能
   1. mode: production
   2. optimization.minimize: true
   3. 提供optimization.minimizer数组

## 核心原理

1. 在构建(make)过程中

   1. 根据当前模块的AST找到import语句，为引入的依赖模块创建 **HarmonyImportSideEffectDependency** ，同时记录 import 的导入变量相关信息，后续遍历AST发现有使用过导入变量，则触发**HarmonyImportDependencyParserPlugin**，为其创建**HarmonyImportSpecifierDependency**并添加到当前模块的依赖数组中，也就是说对于未使用过的导入变量的则不创建Dependency

   ```javascript
   parser.hooks.expression
     .for(harmonySpecifierTag)
     .tap("HarmonyImportDependencyParserPlugin", (expr) => {
       const settings = /** @type {HarmonySettings} */ (parser.currentTagData);
       const dep = new HarmonyImportSpecifierDependency(
         settings.source,
         settings.sourceOrder,
         settings.ids,
         settings.name,
         /** @type {Range} */ (expr.range),
         exportPresenceMode,
         settings.attributes,
         []
       );
       // ...
       parser.state.module.addDependency(dep);
       InnerGraph.onUsage(parser.state, (e) => (dep.usedByExports = e));
       return true;
     });

   ```
   2. 对于所有export 语句分别生成 **HarmonyExportSpecifierDependency**（具名导出）和 **HarmonyExportExpressionDependency**（default导出），并记录导出名字
      ```javascript
      parser.hooks.exportSpecifier.tap(
        "HarmonyExportDependencyParserPlugin",
        (statement, id, name, idx) => {
          const harmonyNamedExports = (parser.state.harmonyNamedExports =
            parser.state.harmonyNamedExports || new Set());
          harmonyNamedExports.add(name);
          // ...
          InnerGraph.addVariableUsage(parser, id, name);
          const dep = new HarmonyExportSpecifierDependency(id, name)

          // ...
          parser.state.current.addDependency(dep);
          return true;
        }
      );

      ```
2. 所有模块编译完后触发compilation.hooks.finishModules，开始执行FlagDependencyExportsPlugin注册的回调函数

   1. 首先遍历所有module对象中的dependencies数组，找到HarmonyExportSpecifierDependency和HarmonyExportExpressionDependency对象，并转换为ExportInfo对象，然后记录到ModuleGraph对象的_exports属性中（后续操作就可以从 ModuleGraph 中直接读取出模块的导出值）
      ```javascript
      asyncLib.each(
        modules,
        (module, callback) => {
          //...
        },
        (err) => {

          let module;

          let exportsInfo;

          const exportsSpecsFromDependencies = new Map();

          const processDependenciesBlock = (depBlock) => {
            for (const dep of depBlock.dependencies) {
              const exportDesc = dep.getExports(moduleGraph); // 拿到HarmonyExportXXXDependency的导出信息
              if (!exportDesc) return;
              exportsSpecsFromDependencies.set(dep, exportDesc);
            }
            // ...
          };

          const processExportsSpec = (dep, exportDesc) => {
            const exports = exportDesc.exports;

            const mergeExports = (exportsInfo, exports) => {
              for (const exportNameOrSpec of exports) {
                let name;
                let exports;
                // ...
                const exportInfo = exportsInfo.getExportInfo(name); // 根据导出值进行创建ExportInfo并记录在moduleGraph中
                // ...
                if (exports) {
                  const nestedExportsInfo = exportInfo.createNestedExportsInfo();
                  mergeExports(
                    /** @type {ExportsInfo} */ (nestedExportsInfo),
                    exports
                  );
                }
                // ../
              }
            };
            mergeExports(exportsInfo, exports);
            // ...
          };

          while (queue.length > 0) {
            module = /** @type {Module} */ (queue.dequeue());

            statQueueItemsProcessed++;

            exportsInfo = moduleGraph.getExportsInfo(module);

            cacheable = true;
            changed = false;

            exportsSpecsFromDependencies.clear();
            moduleGraph.freeze();
            processDependenciesBlock(module);
            moduleGraph.unfreeze();
            for (const [dep, exportsSpec] of exportsSpecsFromDependencies) {
              processExportsSpec(dep, exportsSpec);
            }

          }
          // ...
        }
      );

      ```
3. 触发compilation.hooks.optimizeDependencies钩子，开始执行FlagDependencyUsagePlugin注册的回调函数

   1. 遍历所有modules中依赖数组找到与import产生的Dependency如HarmonyImportSideEffectDependency，通过compilation.getDependencyReferencedExports方法取出引用的导出值，将引用的模块和导出值记录在Map中
   2. 遍历Map集合，拿到module实例的exportsInfo，找到与导出值对应的exportInfo并调用exportInfo.setUsedConditionally方法标记被使用过
4. 触发compilation.seal函数，在compilation.codeGeneration中调用HarmonyExportXXXDependency对应的Template.apply方法

   1. 读取ModuleGraph中的exportsInfo，对于已经使用和没有使用的导出值分别创建HarmonyExportInitFragment（未使用的额外有个unused harmony export xxx注释)，保存在initFragments中
5. 之后通过优化工具如terser去删除未使用的部分
