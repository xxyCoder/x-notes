## 开启条件

1. 使用ESM规范编写代码，从而允许在编译阶段确定模块间的导入/导出关系，从而分析出未被使用的代码
2. optimization.usedExports: true，启用标记功能
3. 启动优化代码功能
   1. mode: production
   2. optimization.minimize: true
   3. 提供optimization.minimizer数组

## 核心原理

1. 在构建(make)过程中，根据AST找到export语句从而将其转换为Dependency对象，并添加到依赖数组中

   1. 具名导出转换为HarmonyExportSpecifierDependency对象
   2. 默认导出转换为HarmonyExportExpressionDependency对象
2. 所有模块编译完后触发compilation.hooks.finishModules，开始执行FlagDependencyExportsPlugin注册的回调函数

   1. 首先遍历所有module对象中的dependencies数组，找到HarmonyExportSpecifierDependency和HarmonyExportExpressionDependency对象，并转换为ExportInfo对象，然后记录到ModuleGraph对象中（后续操作就可以从 ModuleGraph 中直接读取出模块的导出值）
3. 触发compilation.hooks.optimizeDependencies钩子，开始执行FlagDependencyUsagePlugin注册的回调函数

   1. 遍历所有module对象中的exportInfo，为其调用getDependencyReferencedExports方法判断对应的Dependency是否有被使用过
   2. 被使用过的调用exportInfo.setUsedConditionally进行标记（会设置exportInfo._usedInRuntime为true）
4. 触发compilation.seal函数，在compilation.codeGeneration中调用HarmonyExportXXXDependency对应的Template.apply方法

   1. 读取ModuleGraph中的exportsInfo，对于已经使用和没有使用的导出值分别创建HarmonyExportInitFragment（未使用的额外有个unused harmony export xxx注释)，保存在initFragments中
5. 之后通过优化工具如terser去删除未使用的部分
